import asyncio
import sys

# --- Fix for "no current event loop in thread" error on Windows ---
if sys.platform.startswith("win"):
    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

try:
    asyncio.get_running_loop()
except RuntimeError:
    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

import os
import streamlit as st
import spacy
import base64
import pandas as pd
import altair as alt
import graphviz
import time

from langchain_google_genai import ChatGoogleGenerativeAI, GoogleGenerativeAIEmbeddings
from langchain.schema import HumanMessage
from config import GEMINI_API_KEY
from langchain_community.vectorstores import Chroma
from src.nlp_to_model import extract_attributes_from_text
from model import create_block_from_text_results
from simulation_engine import Block, Attribute
from neo4j import GraphDatabase

# ---------------- Setup ----------------

nlp = spacy.load("en_core_web_sm")
os.environ["GOOGLE_API_KEY"] = GEMINI_API_KEY

llm = ChatGoogleGenerativeAI(model="gemini-1.5-flash", location="us-central1")
embeddings = GoogleGenerativeAIEmbeddings(model="embedding-001")
vectorstore = Chroma(persist_directory="./chroma_db", embedding_function=embeddings)
driver = GraphDatabase.driver("bolt://localhost:7687", auth=("neo4j", "test1234"))

# ---------------- Utilities ----------------

def extract_entities(text):
    return [(ent.text, ent.label_) for ent in nlp(text).ents]

def add_to_neo4j(entities):
    with driver.session() as session:
        for entity, label in entities:
            session.run("MERGE (e:Entity {name: $name, type: $type})", name=entity, type=label)

def add_to_vectorstore(text):
    vectorstore.add_texts([text])

# ---------------- Streamlit App ----------------

st.set_page_config(page_title="STK Production GmbH", layout="wide")
st.title("ü§ñ STK Production GmbH ‚Äì AI Assistant")

# ---------------- SECTION 1: Describe Business ----------------

st.header("üßæ Describe Your Business Process")
with st.expander("üí° What does this section do?"):
    st.markdown("""
    In this section, you can describe what‚Äôs happening in your business ‚Äî for example, rising electricity prices or increased consumption.

    We will:
    - Extract named entities from your text
    - Store them in Neo4j
    - Generate a summary using Gemini
    - Attempt to extract numeric inputs and simulate estimated energy costs
    """)

input_text = st.text_area("Tell us what‚Äôs happening ‚Äì cost changes, production, electricity use...")

if st.button("üí¨ Analyze My Description"):
    if not input_text.strip():
        st.warning("‚ö†Ô∏è Please describe your business process first.")
    else:
        st.info("‚è≥ Understanding your input...")
        progress = st.progress(0)
        for i in range(60):
            time.sleep(0.01)
            progress.progress(i + 1)

        # Extract entities & store
        entities = extract_entities(input_text)
        if entities:
            add_to_neo4j(entities)
            add_to_vectorstore(input_text)
            st.markdown("### üîç We found these key terms")
            st.table([{"Entity": e[0], "Type": e[1]} for e in entities])
        else:
            st.info("No named terms (like companies, amounts, locations) were found.")

        # Summary
        with st.expander("üí° What does Gemini do here?"):
            st.markdown("This summary is generated by Gemini based on your business input ‚Äî useful for decision makers and analysts.")
        st.markdown("### üìã Gemini‚Äôs Summary of Your Process")
        prompt_text = f"Summarize the business process: {input_text}"
        gemini_response = llm.predict_messages([HumanMessage(content=prompt_text)])
        st.write(gemini_response.content)

        # Attributes & Simulation ‚Äì only final clean version
        results = extract_attributes_from_text(input_text)
        if results:
            block = create_block_from_text_results(results)
            st.markdown("### üìä Estimated Cost Based on Current Inputs")
            try:
                sim_result = block.simulate()
                if not isinstance(sim_result, dict):
                    raise ValueError("simulate() did not return a dict")

                total_cost = sim_result.get("TotalEnergyCost")
                if total_cost is not None:
                    st.success(f"‚úÖ Based on your inputs, your estimated total monthly energy cost is about **‚Ç¨{total_cost:,.2f}**.")

                # Show simulation results in friendly table
                display = []
                for k, v in sim_result.items():
                    if k == "ElectricityPrice":
                        label = "Electricity Price (‚Ç¨ per kWh)"
                    elif k == "ConsumptionKWh":
                        label = "Monthly Consumption (kWh)"
                    elif k == "MaintenanceCost":
                        label = "Monthly Maintenance Cost (‚Ç¨)"
                    elif k == "TotalEnergyCost":
                        label = "Total Energy Cost (‚Ç¨)"
                    else:
                        label = k
                    display.append({"Metric": label, "Value": f"{v:,.2f}" if isinstance(v, (int, float)) else v})
                st.table(display)
            except Exception as e:
                st.error(f"‚ùå Simulation failed: {e}")
        else:
            st.warning("‚ùå Couldn‚Äôt extract any numerical values.")

# ---------------- SECTION 2: Scenario Simulator ----------------

st.markdown("---")
st.header("üîÑ Simulate a New Scenario")
with st.expander("üí° What does this section do?"):
    st.markdown("""
    This section allows you to simulate a 'what-if' scenario by modifying electricity price and consumption.

    We‚Äôll compare your scenario with the baseline values to help assess cost sensitivity.
    
    You‚Äôll get:
    - Total energy cost
    - Tax estimation
    - Bar chart comparison
    """)

# Base block
base_block = Block("BaseModel")
base_block.add_attribute(Attribute("ElectricityPrice", "input"))
base_block.add_attribute(Attribute("ConsumptionKWh", "input"))
base_block.set_input("ElectricityPrice", 0.45)
base_block.set_input("ConsumptionKWh", 12000)

def total_energy_formula(ctx, visited, cache):
    return ctx.attributes["ElectricityPrice"].evaluate(ctx, visited, cache) * ctx.attributes["ConsumptionKWh"].evaluate(ctx, visited, cache)

def tax_formula(ctx, visited, cache):
    return ctx.attributes["TotalEnergyCost"].evaluate(ctx, visited, cache) * 0.19

base_block.add_attribute(Attribute("TotalEnergyCost", "calculated", total_energy_formula))
base_block.add_attribute(Attribute("EnergyTax", "calculated", tax_formula))

st.write("üìå Current Assumptions:")
st.write({
    "ElectricityPrice": "‚Ç¨0.45 / kWh",
    "ConsumptionKWh": "12,000 kWh"
})

st.markdown("### ‚úèÔ∏è Try a Different Scenario")
new_price = st.number_input("üîπ Electricity Price (EUR/kWh)", value=0.45, step=0.01)
new_kwh = st.number_input("üîπ Monthly Electricity Consumption (kWh)", value=12000, step=100)

if st.button("üìà Run Scenario Simulation"):
    st.info("üß† Running your simulation...")

    scenario_block = Block("ScenarioModel")
    scenario_block.add_attribute(Attribute("ElectricityPrice", "input"))
    scenario_block.add_attribute(Attribute("ConsumptionKWh", "input"))
    scenario_block.set_input("ElectricityPrice", new_price)
    scenario_block.set_input("ConsumptionKWh", new_kwh)
    scenario_block.add_attribute(Attribute("TotalEnergyCost", "calculated", total_energy_formula))
    scenario_block.add_attribute(Attribute("EnergyTax", "calculated", tax_formula))

    base_result = base_block.simulate()
    scenario_result = scenario_block.simulate()

    df = pd.DataFrame({
        "Attribute": list(base_result.keys()),
        "Current": list(base_result.values()),
        "New": list(scenario_result.values())
    })

    st.subheader("üìä Comparison Table")
    st.dataframe(df)

    df_melt = df.melt(id_vars="Attribute", var_name="Scenario", value_name="Value")
    chart = alt.Chart(df_melt).mark_bar().encode(
        x="Attribute:N", y="Value:Q", color="Scenario:N"
    ).properties(width=700)
    st.altair_chart(chart)

    st.markdown("### üìå Key Differences")
    for key in base_result:
        base_val = base_result[key]
        new_val = scenario_result.get(key)
        if isinstance(base_val, (int, float)) and isinstance(new_val, (int, float)) and base_val != new_val:
            st.write(f"üî∏ **{key}** changed by `{new_val - base_val:.2f}`")
